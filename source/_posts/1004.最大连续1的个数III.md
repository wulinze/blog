title: "最大连续1的个数 III"

categories: leetcode

tags: [c++]
---
## 最大连续1的个数 III
### 题目描述

给定一个由若干 `0` 和 `1` 组成的数组 `A`，我们最多可以将 `K` 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 **示例一：**

~~~
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
~~~

**示例二：**

~~~
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
~~~

**提示：**

1. `1 <= A.length <= 20000`
2. `0 <= K <= A.length`
3. `A[i]` 为 `0` 或 `1` 

### 题目分析

反转其中最多K个0使得有最长的连续为1的子数组，连续最长考虑最大窗口尺寸，即遍历数组寻找最大窗口尺寸使得其中0的数目最大为K。考虑设置双指针遍历数组，当要加入的数字为0时则减少K，移除窗口的数字为0则增加K。根据加入窗口的数字选择增大还是缩小窗口，返回最大的窗口尺寸。
$$
\begin{cases}
要加入窗口数字为1 \space\space 增大窗口尺寸\\
要加入窗口数字为0 \space
\begin{cases}
K>0 增大窗口尺寸\\
K<0 最大窗口尺寸保持不变
\end{cases}
\end{cases}
$$

~~~c++
class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
        int left=0, right=0;

        for(; right < A.size(); right++){
            if(A[right] == 0){
                K--;
            }
            while(K<0){
                if(A[left] == 0)K++;
                
                left++;
            }
        }

        return right-left;
    }
};
~~~

