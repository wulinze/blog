title: "还原排列的最小操作次数"

categories: leetcode

tags: [c++]
---
### 题目描述

给你一个偶数 `n` ，已知存在一个长度为 `n` 的排列 `perm` ，其中 `perm[i] == i`（下标 **从 0 开始** 计数）。

一步操作中，你将创建一个新数组 `arr` ，对于每个 `i` ：

- 如果 `i % 2 == 0` ，那么 `arr[i] = perm[i / 2]`
- 如果 `i % 2 == 1` ，那么 `arr[i] = perm[n / 2 + (i - 1) / 2]`

然后将 `arr` 赋值给 `perm` 。

要想使 `perm` 回到排列初始值，至少需要执行多少步操作？返回最小的 **非零** 操作步数。

**示例1：**

~~~
输入：n = 2
输出：1
解释：最初，perm = [0,1]
第 1 步操作后，perm = [0,1]
所以，仅需执行 1 步操作
~~~

**示例2：**

```
输入：n = 4
输出：2
解释：最初，perm = [0,1,2,3]
第 1 步操作后，perm = [0,2,1,3]
第 2 步操作后，perm = [0,1,2,3]
所以，仅需执行 2 步操作
```

### 题目分析

​	对于一次操作会将数组变为如下格式

对于基本的变换公式进行等价替换

* 如果 `i % 2 == 0` ，那么 `arr[i] = perm[i / 2]`
* 如果 `i % 2 == 1` ，那么 `arr[i] = perm[n / 2 + (i - 1) / 2]`

以上为初始的变换公式

下面为等价的变换公式

* 如果 `i < n/2` ，那么 下标`i变为2i`
* 如果 `i >= n/2` ，那么 下标`i变为2i-(n-1)`

设$f(i)=2i \ mod\ (n-1)$那么对于k次变换则有$f^k(i)=2^ki=2i\ mod\ (n-1)$上标k代表$f(f(i))$执行k次,而如果使得恢复为初始数组则需要满足$2i\ mod\ (n-1)=i\ mod\ (n-1)$

因此只需要找到一个最小的k使得$2^k=1\ mod\ (n-1)$

~~~c++
class Solution {
public:
    int reinitializePermutation(int n) {
        if(n <= 2) return 1;
        int k=1;
        int pow = 2;

        while(pow != 1){
            k++;
            pow = (2 * pow) % (n-1);
        }

        return k;
    }
};
~~~





